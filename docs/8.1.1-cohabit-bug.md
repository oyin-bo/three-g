# 8.1.1 Cohabiting Particles Bug

## The Bug

**Both monopole and quadrupole Barnes-Hut implementations fail to compute correct forces for particles in the same voxel.**

This is a fundamental error that violates basic gravitational physics:
- **Monopole**: Uses voxel COM including the particle's own mass → self-interaction artifact + wrong magnitude
- **Quadrupole**: Skips own voxel entirely → no forces between cohabiting particles

Both violate the Barnes-Hut algorithm's requirement to eventually resolve to direct N² pairwise forces when subdivision cannot continue.

## Manifestation

### Monopole (`gravity/multipole/shaders/traversal.frag.js`)

**Old code (lines 196-236):** Used voxel COM for all 27 voxels in 3×3×3 neighborhood, including own voxel.

**Problem:** When particle `i` at position `p_i` with mass `m_i` computes force from its own voxel:
```
COM = (m_i * p_i + Σ(m_j * p_j)) / (m_i + Σ(m_j))   [includes particle i]
F_i = G * (total_mass) * (COM - p_i) / |COM - p_i|³  [WRONG]
```

This creates:
1. **Self-interaction**: Particle feels phantom force from "its own mass at the COM"
2. **Wrong magnitude**: Off by factor of `[(m_i + Σm_j) / Σm_j]³`
3. **Wrong direction**: COM depends on particle's own position

**Correct physics:**
```
F_i = Σ(G * m_j * (p_j - p_i) / |p_j - p_i|³)  [for j ≠ i in same voxel]
```

### Quadrupole (`gravity/multipole/k-traversal-quadrupole.js`)

Lines 603-604:

```glsl
// Skip own voxel
bool isMyVoxel = (testVoxel.x == myVoxel.x && testVoxel.y == myVoxel.y && testVoxel.z == myVoxel.z);
if (isMyVoxel) continue;
```

Lines 598-600:

```glsl
vec4 a0 = sampleLevelA0(level, texCoord);
float mass = a0.w;  // Total mass of voxel
```

**Two problems:**
1. **Skips own voxel entirely** - particles in same voxel feel NO force from each other
2. **Uses COM approximation** for neighboring voxels - not individual particle interactions

## Impact

If voxel [5,5,5] contains particles [15, 234, 500, 1023]:

**Current behavior:**
- Particle 15 **ignores** particles 234, 500, 1023 (same voxel → skipped)
- For neighboring voxel [6,5,5] with particles [88, 456, 1200]:
  - Particle 15 treats them as **single point mass** at voxel COM
  - **NO individual pairwise forces**

**Consequences:**
- Particles can overlap without repelling
- Close encounters completely inaccurate
- Dense clusters behave incorrectly
- Energy non-conservation at small scales

## Fix Implementation (Monopole)

**Date:** October 30, 2025

**Modified:** `gravity/multipole/shaders/traversal.frag.js`

**Strategy:** Direct particle-particle forces for own voxel only (minimal fix).

### Changes

**Own voxel:** Loop through all particles, compute direct pairwise forces for those in same voxel
- O(N) loop per particle, but only processes particles in same voxel
- Correct physics: no self-interaction, proper 1/r² force law

**Neighboring voxels:** Keep using COM approximation (unchanged)
- Acceptable when particles are separated by at least one cell width
- Same performance as before

### Code

```glsl
// First, handle own voxel with direct particle-particle forces
for (int i = 0; i < u_particleCount; i++) {
  if (i == myIndex) continue; // Skip self
  
  vec4 otherData = texture(u_particlePositions, otherUV);
  vec3 otherPos = otherData.xyz;
  float otherMass = otherData.w;
  
  // Check if other particle is in same voxel
  ivec3 otherVoxel = ivec3(floor(otherNorm * gridSize));
  if (all(equal(otherVoxel, myL0Voxel))) {
    // Same voxel - compute direct force
    vec3 delta = otherPos - myPos;
    float inv = 1.0 / ((dot(delta,delta) + eps²) * sqrt(...));
    totalForce += delta * otherMass * inv;  // CORRECT
  }
}

// Now handle neighboring voxels with COM (same as before)
for (neighboring voxels excluding own) {
  vec3 com = nodeData.rgb / mass;
  totalForce += (com - myPos) * mass * inv;  // Acceptable approximation
}
```

### Performance Impact

**Worst case:** All N particles in one voxel → O(N²) total (same as direct summation)

**Typical case:** Particles distributed across voxels:
- Own voxel: O(k) where k = particles per voxel (typically < 10)
- Neighboring voxels: O(1) per voxel (26 voxels)
- **Total per particle:** O(k + 26) ≈ O(1) when well-distributed

**Expected:** Small performance hit (5-20%) for typical particle distributions, correct physics.

### Verification Needed

- [ ] Energy conservation test
- [ ] Two-particle collision test (same voxel)
- [ ] Dense cluster stability
- [ ] Performance benchmark vs. old code

## Fix Implementation (Quadrupole)

**Status:** TODO (separate effort)

Same strategy applies, but more complex due to quadrupole moment handling.
