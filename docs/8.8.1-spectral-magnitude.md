# Spectral magnitude discrepancy: evidence and analysis

This document collects hard evidence for the observed magnitude mismatch in the spectral (PM/FFT) pipeline, clarifies what parts are working, lists likely causes, and provides context and links to the source diagnostics and code.

## Scope

- Focus: Under 32³ tests, the real-space force grid and sampled particle forces are much smaller than the analytic expectation for simple setups (e.g., two-body at r=2, G=3e-4).
- Out of scope (contextual): 64³ runs show NaNs that originate before spectral stages (integration/bounds issue). We reference them only for context.

## What we observe (evidence)

### Two-body, 32³ grid (magnitude is too small)

Source: [`15-oak-0153-46.md`](./15-oak-0153-46.md) → “small-scale: two particles attract each other” failure.

- Setup summary (from the dump):
  - Grid: 32³, world bounds ≈ [-3,3]³ (worldSize [6,6,6])
  - Two particles at x = -1 and +1, masses 1 each
  - Timestep dt = 0.01, G = 3e-4, soft = 0.15
- Spectral force spectrum peak magnitude:
  - forceSpectrumX.real range includes max ≈ +0.6420 and min ≈ -0.5535
- Inverse FFT (force grid X component):
  - forceGridX.fx range: [-3.57e-5, +2.32e-5]
- Sampled forces at particle positions (trilinear):
  - totalForceMag ≈ 1.94e-6
  - fx mean ≈ 1.00e-6; fy ≈ 3.43e-7; fz ≈ -1.63e-6

All of the above are captured verbatim in:
- [`15-oak-0153-46.md`](./15-oak-0153-46.md) (search for: “small-scale: two particles attract each other”).

Analytic baseline for comparison:
- For two unit masses separated by r = 2, Newtonian |F| = G / r² = 3e-4 / 4 = 7.5e-5.
- Observed sampled force magnitude is O(1e-6), roughly 50–150× smaller than 7.5e-5, depending on component and sample.

### Mass deposition sanity in 32³

- Multiple 32³ diagnostics report the correct total mass after deposit:
  - Two-body: massGrid totalMass = 2.000
  - Other 32³ tests in the same session show totals (e.g., 20.00, 30.00, 50.00) matching the number of unit-mass particles
-- Reference: same [`15-oak-0153-46.md`](./15-oak-0153-46.md), sections showing “massGrid: totalMass=…”.

### 64³ runs produce NaNs before spectral math (context only)

- In several 64³ cases, positions are already NaN at KDeposit; massGrid totalMass=NaN; complex imag channel is often 0 before it becomes NaN downstream.
- This indicates an integration/bounds robustness issue, not a spectral-math issue.
-- Reference: same [`15-oak-0153-46.md`](./15-oak-0153-46.md), sections titled “known-solutions … free-fall”, “circular orbit …”, “large-scale …”.

## What works (hard evidence)

- Forward/inverse FFT normalization and pipeline wiring:
  - Inverse normalization is applied as 1/N³ when writing real output.
  - Code: [`../particle-system/gravity-spectral-kernels/k-fft.js`](../particle-system/gravity-spectral-kernels/k-fft.js) sets `u_normalizeInverse = 1/(N³)` for the final inverse stage.
  - Shader: [`../particle-system/gravity-spectral-kernels/shaders/fft.frag.js`](../particle-system/gravity-spectral-kernels/shaders/fft.frag.js) (collapsed='to') multiplies the real part by `u_normalizeInverse` before writing to R32F.
- Poisson formulation is standard and guarded:
  - φ(k) = -4πG ρ(k) / k², with safe handling at k=0; supports discrete vs continuous k².
  - Code: [`../particle-system/gravity-spectral-kernels/shaders/poisson.frag.js`](../particle-system/gravity-spectral-kernels/shaders/poisson.frag.js).
- Gradient formulation is correct:
  - F(k) = -i k φ(k), per-axis.
  - Code: [`../particle-system/gravity-spectral-kernels/shaders/gradient.frag.js`](../particle-system/gravity-spectral-kernels/shaders/gradient.frag.js).
- Force sampling matches the grid (no extra scaling):
  - Trilinear interpolation from real-space force grids; uses world bounds mapping.
  - Code: [`../particle-system/gravity-spectral-kernels/shaders/force-sample.frag.js`](../particle-system/gravity-spectral-kernels/shaders/force-sample.frag.js).
- Mass deposition behaves and conserves total mass (in 32³ evidence):
  - Additive blending to R32F; NGP/CIC paths, world→grid mapping in the vertex shader.
  - Code: [`../particle-system/gravity-spectral-kernels/k-deposit.js`](../particle-system/gravity-spectral-kernels/k-deposit.js), [`../particle-system/gravity-spectral-kernels/shaders/pm-deposit.frag.js`](../particle-system/gravity-spectral-kernels/shaders/pm-deposit.frag.js).

These working pieces align with the consistent force magnitudes seen across inverse-FFT force grids and the sampled forces, i.e., sampling doesn’t radically rescale – it preserves the grid’s small amplitudes.

## Likely root causes of the magnitude discrepancy

- Missing conversion from mass to physical density before Poisson
  - The PM mass grid stores mass per voxel (unit: mass), but Poisson expects density ρ(x) (unit: mass/volume).
  - The physical density should be ρ = mass / ΔV, with ΔV = (Lx/N)·(Ly/N)·(Lz/N) = (Lx·Ly·Lz)/N³.
  - If the pipeline feeds “mass” instead of “density” into the FFT/Poisson, φ and hence F will be scaled down by ΔV.
  - For worldSize L = 6 in each axis and N = 32: ΔV = (6/32)³ = 0.1875³ ≈ 6.59e-3. Missing 1/ΔV ≈ 151.9× would make forces ~152× smaller than analytic — in the right ballpark for the observed 50–150× shortfall.
  - Code inspection:
    - Deposit: [`../particle-system/gravity-spectral-kernels/k-deposit.js`](../particle-system/gravity-spectral-kernels/k-deposit.js)/[`../particle-system/gravity-spectral-kernels/shaders/pm-deposit.frag.js`](../particle-system/gravity-spectral-kernels/shaders/pm-deposit.frag.js) writes mass, not density.
    - Poisson: [`../particle-system/gravity-spectral-kernels/shaders/poisson.frag.js`](../particle-system/gravity-spectral-kernels/shaders/poisson.frag.js) treats the input as ρ(k) and does not divide by voxel volume.
- Assignment window deconvolution might be off by a constant factor
  - [`../particle-system/gravity-spectral-kernels/shaders/poisson.frag.js`](../particle-system/gravity-spectral-kernels/shaders/poisson.frag.js) applies a product of sinc windows raised to `u_deconvolveOrder` for NGP/CIC/TSC.
  - The exact 1D window for CIC in Fourier space is W1D(k) ≈ sinc(kΔx/2)²; implementation uses `sinc(π·kg/N)` raised to order – this could differ by constant factors depending on convention (grid vs physical wave numbers).
  - A constant gain error here would also uniformly scale force magnitudes.
- Potential double-counting or omission of physical scaling in k-space
  - [`../particle-system/gravity-spectral-kernels/shaders/poisson.frag.js`](../particle-system/gravity-spectral-kernels/shaders/poisson.frag.js) computes k² using physical k_phys = 2π·kg/L; gradient uses the same physical k scaling.
  - If the input spectrum isn’t in physical units (i.e., mass vs density), the combined unit scaling will produce mismatched magnitudes consistently across setups.

Secondary suspects and non-factors:
- Softening: Not applied in the spectral pipeline here; unlikely to explain large uniform scaling.
- Sampling attenuation: Trilinear interpolation at particle positions is consistent with grid magnitudes; it doesn’t add a >10× scale change.
- FFT normalization: Verified as correct (forward unnormalized, inverse 1/N³) and consistent with observed spectrum→grid magnitudes.

## Context and links

  - Diagnostics with full numeric dumps and timing:
  - [`15-oak-0153-46.md`](./15-oak-0153-46.md) (search for the failing tests named in this document; includes 32³ two-body and various 64³ cases).
- Spectral pipeline code:
  - FFT kernel: [`../particle-system/gravity-spectral-kernels/k-fft.js`](../particle-system/gravity-spectral-kernels/k-fft.js)
  - FFT shader: [`../particle-system/gravity-spectral-kernels/shaders/fft.frag.js`](../particle-system/gravity-spectral-kernels/shaders/fft.frag.js)
  - Poisson shader: [`../particle-system/gravity-spectral-kernels/shaders/poisson.frag.js`](../particle-system/gravity-spectral-kernels/shaders/poisson.frag.js)
  - Gradient shader: [`../particle-system/gravity-spectral-kernels/shaders/gradient.frag.js`](../particle-system/gravity-spectral-kernels/shaders/gradient.frag.js)
  - Force sampling shader: [`../particle-system/gravity-spectral-kernels/shaders/force-sample.frag.js`](../particle-system/gravity-spectral-kernels/shaders/force-sample.frag.js)
  - Deposit kernel: [`../particle-system/gravity-spectral-kernels/k-deposit.js`](../particle-system/gravity-spectral-kernels/k-deposit.js)
  - Deposit fragment shader: [`../particle-system/gravity-spectral-kernels/shaders/pm-deposit.frag.js`](../particle-system/gravity-spectral-kernels/shaders/pm-deposit.frag.js)

## Recommended verification steps for the specialist team

- Normalize mass grid to physical density before FFT/Poisson:
  - Option A: Divide the real-space mass grid by voxel volume ΔV prior to forward FFT.
  - Option B: Multiply the spectrum by 1/ΔV inside [`../particle-system/gravity-spectral-kernels/shaders/poisson.frag.js`](../particle-system/gravity-spectral-kernels/shaders/poisson.frag.js) before applying the Green’s function.
  - Verify that this change lifts 32³ two-body sampled |F| toward ≈ 7.5e-5.
- Cross-check assignment deconvolution constants:
  - Re-derive CIC/TSC window factors in terms of the shader’s kg/N convention; adjust power/arguments if needed to match standard PM references.
- Keep 64³ NaN debugging separate:
  - Those NaNs appear before spectral stages (positions NaN in KDeposit). They’re likely due to integration/bounds or NaN-guarding issues, not spectral magnitude math.

## Conclusion

- The spectral math (FFT normalization, Poisson, gradient) and sampling/deposit plumbing function as designed, but the magnitude of forces is consistently too small in 32³ runs.
- The most probable cause is an omitted mass→density normalization by voxel volume, potentially compounded by a constant-factor mismatch in assignment window deconvolution. Adjusting for ΔV should move forces toward analytic expectations.

## Proposed change: KFFT uniform-based normalization (forward-only)

Introduce a small, reversible change in the KFFT pipeline to convert mass-per-voxel to physical density via a uniform scale, applied only on the forward path that ingests the mass grid. This keeps the mass grid semantics intact for other consumers while giving the spectral pipeline the density that Poisson expects.

Rationale
- Mass deposit currently accumulates mass per voxel (units: mass).
- Poisson expects physical density ρ (mass/volume); required conversion factor is 1/ΔV, where ΔV = (Lx·Ly·Lz)/N³.
- Applying the factor only on the forward (mass→spectrum) path avoids touching deposit, sampling, or inverse FFT code, and does not require any “de-multiply” on the way back.

Changes (concise)
1) Shader generator (KFFT “collapsed” variants)
  - Add a new uniform in the generator for collapsed forward passes that read the mass grid, e.g. `uniform float u_massToDensity;`.
  - Gate the use of this uniform behind a conditional that only applies when the source texture is the mass grid and the phase is forward/collapsed-from (do not apply in inverse/collapsed-to): multiply the sampled scalar by `u_massToDensity` before packing to complex.
  - Do not apply any de-scaling in the collapsed-to (inverse) variant. The 1/ΔV conversion is a physical unit change, not an FFT normalization to be undone.

2) KFFT class (JS)
  - Add an argument/property (e.g., `massToDensity = 1.0`) to the KFFT constructor/options so the particle system can update it at runtime when worldSize/gridSize change.
  - During forward runs that read from the mass grid, bind the uniform to a value. The value should be calculated by the external code (particle system) this way: `massToDensity = 1.0 / ΔV`, where `ΔV = (Lx * Ly * Lz) / (N * N * N)` and `Lx,Ly,Lz` come from world bounds.
  - For all other forward passes (non-mass inputs) and all inverse passes, omit the uniform entirely in the shader and do not bind inside KFFT run method.

Contract (quick)
- Input: mass grid (mass-per-voxel).
- Output (to Poisson): spectrum corresponding to density ρ(x) = mass(x)/ΔV.
- No change to inverse path: inverse FFT and force-grid writes remain as-is (still using existing 1/N³ inverse normalization).

Defaults and updates
- Do not default `massToDensity`, it must be provided.
- If world bounds ever adjusted, set `massToDensity = N³ / (Lx·Ly·Lz)` immediately, or make a recalculation on every frame before scheduling KFFT run.

Validation
- Two-body 32³ case: expect sampled |F| to increase by ≈ N³/(L³) (e.g., ≈151.9× for L=6, N=32), moving toward the analytic 7.5e-5 baseline.
- If a small residual scale remains, verify assignment-window deconvolution constants next (CIC/TSC) and confirm discrete-vs-continuous k² mode selections.

## Critical Re-assessment of the `massToDensity` Proposal

The proposal to use a single `massToDensity` uniform, while correctly identifying the missing mass-to-density conversion as a root cause, is fundamentally flawed for non-cubic world boundaries.

### The Flaw in Uniform Scaling

The proposed solution calculates a single conversion factor `1/ΔV` based on the total world volume `Lx·Ly·Lz`. This implicitly assumes that every voxel in the computational grid corresponds to a physical cube of the same volume. This is only true if the world bounds are cubic (i.e., `Lx = Ly = Lz`).

However, the simulation often uses non-cubic, "squashed" world bounds (e.g., `worldSize: [4, 0.2, 4]`). In this scenario:
- The computational grid remains uniform (e.g., 64x64x64).
- The physical space is non-uniform. A voxel that is `1/64` of the grid's extent in each dimension corresponds to a physical volume of `(Lx/64) * (Ly/64) * (Lz/64)`.
- If `Lx`, `Ly`, and `Lz` are different, the physical shape of a voxel is a rectangular prism, not a cube.

Applying a single, averaged volume correction `1/ΔV` across the entire grid is physically incorrect. It over-corrects in the larger dimensions and under-corrects in the squashed dimension, leading to distorted, non-physical forces.

The core issue is the mismatch between the uniform grid assumed by the FFT and the non-uniform physical space it represents.

## A Fundamentally Sound Model for Spectral Calculations

A correct model must properly relate the discrete, computational grid to the continuous, physical space at each step. Throughout this analysis, `N` refers to the size of one dimension of the computational grid (e.g., `N=64` for a `64x64x64` grid), as the current FFT implementation assumes the grid is cubic (all dimensions are equal). The key is to understand how physical units and FFT normalization interact.

### Derivation

1.  **Physical Density (`ρ`)**: The `deposit` stage creates a grid of `mass` per voxel. Poisson's equation requires physical `density`, which is `mass / volume`.
    - Let the grid size be `N x N x N`.
    - Let the physical world dimensions be `Lx, Ly, Lz`.
    - The volume of a single voxel is `ΔV = (Lx/N) * (Ly/N) * (Lz/N) = (Lx·Ly·Lz) / N³`.
    - Therefore, the physical density is:
      `ρ(x) = mass(x) / ΔV = mass(x) * N³ / (Lx·Ly·Lz)`

2.  **Forward FFT (`FFT`)**: The FFT is a numerical operation. When we compute the FFT of the density grid, we get the spectrum `ρ_k = FFT(ρ)`.

3.  **Poisson's Equation**: This must be solved in physical Fourier space.
    - The physical wave vector `k_phys` is related to the grid wave vector `k_grid` (integers from `-N/2` to `N/2`) by the world size: `k_phys = 2π * k_grid / L`. This is anisotropic for non-cubic worlds.
    - The potential spectrum is `φ_k = -4πG * ρ_k / |k_phys|²`.

4.  **Gradient**: The force spectrum is the gradient of the potential spectrum.
    - `F_k = -i * k_phys * φ_k`

5.  **Inverse FFT (`IFFT`)**: The final step is to transform the force spectrum back to real space. The standard numerical IFFT includes a normalization factor of `1/N³`.
    - `F(x) = IFFT(F_k) = (1/N³) * Σ(F_k * e^(i*k*x))`

### The Cancellation of `N³`

Let's substitute the equations to see the final force calculation:

`F(x) = IFFT( -i * k_phys * φ_k )`
`F(x) = IFFT( -i * k_phys * (-4πG * ρ_k / |k_phys|²) )`
`F(x) = IFFT( -i * k_phys * (-4πG * FFT(ρ) / |k_phys|²) )`
`F(x) = IFFT( -i * k_phys * (-4πG * FFT(mass(x) * N³ / (Lx·Ly·Lz)) / |k_phys|²) )`

Since the FFT is a linear operator, `FFT(c*f) = c*FFT(f)`. The `N³ / (Lx·Ly·Lz)` term is a constant `c`.

`F(x) = IFFT( (N³ / (Lx·Ly·Lz)) * [ ... FFT(mass(x)) ... ] )`

The IFFT applies a `1/N³` scaling:

`F(x) = (1/N³) * (N³ / (Lx·Ly·Lz)) * IFFT_unnormalized( [ ... FFT(mass(x)) ... ] )`

The `N³` terms cancel out.

`F(x) = (1 / (Lx·Ly·Lz)) * IFFT_unnormalized( ... )`

### The Corrected Implementation

The `N³` factor from the mass-to-density conversion and the `1/N³` factor from the IFFT normalization cancel each other perfectly. This leads to a much simpler and more robust implementation.

1.  **Remove `u_normalizeInverse` from the IFFT**: The `1/N³` scaling in the final `k-fft.js` inverse pass should be removed. The FFTs should be unnormalized in both directions.

2.  **Introduce `u_worldVolume` in Poisson Shader**: The `poisson.frag.js` shader, which currently solves for `φ_k = -4πG * ρ_k / k²`, should instead solve for:
    `φ_k = -4πG * (mass_k / u_worldVolume) / k_phys²`
    Where `mass_k` is the direct FFT of the mass grid, and `u_worldVolume` is `Lx * Ly * Lz`.

This approach is physically sound because:
- It correctly computes density within the physical Poisson equation.
- It correctly uses anisotropic `k_phys` vectors that account for the non-cubic world shape.
- It avoids the flawed concept of a single `massToDensity` scalar and removes the confusing interaction with FFT normalization factors. The `N³` terms vanish from the final equation, simplifying the implementation and removing potential sources of error.

### Followup refactoring to Non-Cubic Grids

Support for non-cubic computational grid with dimensions `Nx, Ny, Nz` is a necessary next step. The model presented above remains **fundamentally sound** in this context.

The primary benefit is **computational efficiency**. For a world of size `[10, 1, 10]`, a cubic grid might require a `100x100x100` resolution to capture detail in the large dimensions, wasting effort on the short axis. A non-cubic grid could use a `100x10x100` grid, achieving the same physical resolution with a 10x reduction in memory and computation. Or alternatively, it could increase dimensionality in all axes to deliver higher precision for the same cost as `100x100x100`.

The required changes are as follows:

1.  **FFT Kernels (`k-fft.js`, `fft.frag.js`):** This is the most significant part of the work.
    -   The FFT implementation must be generalized from a single `gridSize` (`N`) to a `vec3` or `ivec3` representing `(Nx, Ny, Nz)`.
    -   Uniforms passed to the shaders must be updated to carry these per-axis dimensions.
    -   The shader logic for calculating texture coordinates during the FFT's butterfly passes will need to be adjusted to handle the non-cubic grid dimensions.

2.  **Physics Kernels (`poisson.frag.js`, `gradient.frag.js`):** These require only minor adjustments.
    -   The calculation of the physical wave vector `k_phys` already correctly uses the anisotropic world dimensions `(Lx, Ly, Lz)`.
    -   This calculation would be updated to use the corresponding grid dimensions `(Nx, Ny, Nz)` when converting from the integer grid wave vector `k_grid`.

3.  **Normalization and Physical Scaling:** The core conclusion of the "fundamentally sound model" is reinforced by this change.
    -   The IFFT normalization factor would become `1 / (Nx·Ny·Nz)`.
    -   The mass-to-density conversion factor would become `(Nx·Ny·Nz) / (Lx·Ly·Lz)`.
    -   As before, these two terms cancel each other out perfectly.

Therefore, the conclusion is robust: the FFT normalization should be removed entirely, and the physical scaling should be handled solely by a `1 / u_worldVolume` factor in the Poisson shader. This principle holds regardless of the grid's geometry, making the proposed model both correct and forward-compatible with this optimization.
